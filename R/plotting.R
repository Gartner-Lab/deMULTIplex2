


#' Tag-Count Histograms
#' Plot log-scaled UMI histograms for each unique tag (in clean datasets, these will appear bimodal) and total UMI counts. \cr
#' Helpful for visualizing tag data and diagnosing classification problems.
#'
#' @param tag_mtx Tag count matrix as generated by alignTags()
#' @param minUMI Exclude cells from plotting that do not have this minimum number of total tag UMIs (default: 10)
#' @param plotnUMI logical; Whether or not to plot log-scaled nUMI as well (default: TRUE)
#' @param select Numeric vector identifying specific barcodes (columns of tag_mtx) to plot
#' @param scale_y logical; Whether or not to square-root-scale the y-axis to improve visualization (default: FALSE)
#' @param bins Number of bins passed on to geom_histogram() (default: 100)
#' @param colors Values passed on scale_fill_manual() if desired
#'
#' @export
tagHist <- function(tag_mtx,
                    minUMI = 10,
                    plotnUMI = TRUE,
                    select = NULL,
                    scale_y = FALSE,
                    bins = 100,
                    colors = NULL) {
    require(tidyr)
    require(ggplot2)
    require(cowplot)

    tag_mtx <- as.data.frame(tag_mtx)
    # make sure there is a nUMI column
    if ("nUMI" %ni% colnames(tag_mtx)) {
        tag_mtx$nUMI <- rowSums(tag_mtx)
    }

    # select specific barcodes if desired
    if (!is.null(select)) {
        tag_mtx <- tag_mtx[,c(colnames(tag_mtx)[select], "nUMI")]
    }

    # remove outliers and low-UMI cells (or empty droplets) to improve visualization
    lo <- max(quantile(tag_mtx$nUMI,0.001), minUMI)
    hi <- quantile(tag_mtx$nUMI,0.999)
    ind <- tag_mtx$nUMI < hi & tag_mtx$nUMI > lo
    tag_mtx <- tag_mtx[ind,]

    if (plotnUMI == FALSE) {
        tag_mtx$nUMI <- NULL
    }

    # reorganize dataframe to facilitate plotting
    x <- pivot_longer(tag_mtx, cols = 1:ncol(tag_mtx), names_to = "Barcode", values_to = "Count")
    x$Barcode <- factor(x$Barcode, levels = colnames(tag_mtx))

    p <- ggplot(x, aes(x = Count, fill = Barcode)) +
        geom_histogram(bins = bins, alpha = 0.6) +
        scale_x_log10() +
        theme_bw() +
        ggtitle(paste("nCell: ", nrow(tag_mtx), "\n", "minUMI: ", lo, sep="")) +
        theme(plot.title = element_text(size=10))

    if (ncol(tag_mtx) > 10) {
        ncol <- ceiling(sqrt(ncol(tag_mtx)/3))
        p <- p + facet_wrap(facets = "Barcode", ncol = ncol, scales = "free_y")
    } else {
        p <- p + facet_grid(rows = "Barcode", scales = "free_y")
    }

    if (scale_y) { p <- p + scale_y_sqrt() }
    if (!is.null(colors)) { p <- p + scale_fill_manual(values = colors) }

    p
}



#' Classification x Tag Heatmap
#'
#' After completing classifications, plot sample tag x classification heatmap, with values representing the average tag count for each classified sample. Helpful visualization for troubleshooting your dataset.
#'
#' @param tag_mtx Tag count matrix as generated by alignTags()
#' @param calls Character vector of classification results
#' @param log logical; Whether to log-scale tag counts (default: TRUE)
#' @param colLow Color representing the minimum value of the heatmap
#' @param colHigh Color representing the maximum value of the heatmap
#'
#' @export
tagCallHeatmap <- function(tag_mtx,
                       calls,
                       log = TRUE,
                       colLow = "white",
                       colHigh = "#c73647") {
    require(pheatmap)
    require(tidyr)

    if (sum(names(calls) %ni% rownames(tag_mtx)) > 0) {
        return(message("Error: cell barcodes do not match"))
    }

    if (log) {
        tag_mtx <- log10(tag_mtx)
    }

    tag_mtx[tag_mtx == -Inf] <- 0

    calltypes <- unique(calls)

    tmp <- sapply(calltypes, function(x) {
        df <- tag_mtx[names(calls[calls == x]),]
        colMeans(df)
    })
    colnames(tmp) <- calltypes
    rownames(tmp) <- colnames(tag_mtx)

    bar <- colnames(tag_mtx)[colnames(tag_mtx) != "nUMI"] %>% as.character()
    doub <- calltypes[calltypes %ni% c(bar, "Negative", NA)] %>% as.character()
    neg <- calltypes[calltypes %ni% c(bar, doub)] %>% as.character()

    order <- c(bar, doub, neg)

    tmp <- tmp[,order]

    tmp_df <- as.data.frame(tmp)
    tmp_df$Barcode <- rownames(tmp_df)
    tmp_df <- pivot_longer(tmp_df, cols = 1:ncol(tmp), names_to = "Call", values_to = "Mean")
    tmp_df$Call <- factor(tmp_df$Call, levels = order)
    tmp_df$Barcode <- factor(tmp_df$Barcode, levels = rev(rownames(tmp)))

    ggplot(tmp_df, aes(x = Call, y = Barcode, fill = Mean, label = round(Mean,1))) +
        geom_tile(color = 'grey') +
        geom_text() +
        theme_classic() +
        scale_fill_gradient(low = colLow, high = colHigh) +
        theme(axis.text.x = element_text(angle = -45, hjust = 0))
}












